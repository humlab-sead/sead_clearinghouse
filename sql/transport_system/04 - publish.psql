create or replace function clearing_house_commit.publish_resolved_submission(p_submission_id int, p_dry_run boolean = TRUE)
    returns setof text as $$
declare
    v_table_name character varying;
    v_entity_name character varying;
    v_pk_name character varying;
    v_sql text = '';
begin
    begin
        for v_table_name, v_entity_name, v_pk_name in (select distinct table_name, entity_name from clearing_house_commit.tbl_sead_tables)
        loop
            v_sql = format('insert into public.%s clearing_house_commit.resolve_%s(%s);', v_table_name, v_entity_name, p_submission_id);
             /* on conflict (v_pk_name) update set .... */
            if (not p_dry_run) then
                 execute v_sql;
            end if;
            return next v_sql;
        end loop;
    end;
end;$$ language plpgsql;


create or replace function clearing_house_commit.read_site_file(p_submission_id int)
    returns setof public.tbl_sites as $xyz$
declare
   v_command character varying;
begin
    drop table if exists clearing_house_commit.temp_sites;
    create /* temporary unlogged*/ table clearing_house_commit.temp_sites
        as select * from public.tbl_sites where false
            with no data;
    v_command = format('copy clearing_house_commit.temp_sites from program ''gunzip -c /tmp/submission_%s_site.gz''', lpad(p_submission_id::text, 3, '0'));
    execute v_command;
    return query select * from clearing_house_commit.temp_sites;
    drop table if exists clearing_house_commit.temp_sites;
end $xyz$ language plpgsql;



-- FUNKAR MEN SKAPAR EJ CR:
-- select clearing_house_commit.publish_resolved_submission(3, FALSE)

create or replace function clearing_house_commit.generate_resolved_submission_copy_out_script(p_submission_id int, p_folder character varying)
    returns text as $xyz$
declare
   v_sql_copy_out character varying;
   v_sql_copy_in character varying;
   v_copy_template character varying;
   v_sql character varying;
   v_filename_template character varying;
   v_filename_name character varying;
   v_table_name character varying;
   v_pk_name character varying;
   v_entity_name character varying;
begin
    begin

        -- v_sql_template = E'\copy (select * from clearing_house_commit.resolve_%s(%s)) to program ''zip -c ./data/submission_%s_%s.gz'';\n';

        v_filename_template = '''%s/submission_%s_%s.txt'';';

        v_copy_out_template = '
            copy (select * from clearing_house_commit.resolve_%s(%s)) to file ''%s'';
        ';

        v_copy_in_template = '
            create schema if not exists sead_import_temp;

            create table sead_import_temp.%s as select * from public.%s where FALSE;

            copy sead_import_temp.%s from file ''%s'';

            insert into public.%s
                select *
                from sead_import_temp.%s
                /* on conflict (v_pk_name) update */;

        ';

        v_sql_copy_out = '';
        v_sql_copy_in = '';

        for v_table_name, v_pk_name, v_entity_name in (
            select distinct table_name, pk_name, entity_name
            from clearing_house_commit.tbl_sead_tables
        )
        loop

            v_filename_template = format(v_filename_template, p_folder, lpad(p_submission_id::text, 3, '0'), v_entity_name);

            v_sql = format(v_copy_out_template, v_entity_name, p_submission_id, v_filename_name);

            v_sql_copy_out = v_sql_copy_out || v_sql;

            v_sql = format(v_copy_in_template, v_table_name, v_table_name, v_filename_name, v_table_name, v_table_name);

            v_sql_copy_in = v_sql_copy_in || v_sql;

        end loop;

        v_sql_copy_in = '
            begin transaction;

                drop schema if exists sead_import_temp cascade;
                create schema sead_import_temp;' ||
                    v_sql_copy_in || '

            commit transaction;
            ';
    end;

    return v_sql_copy_in;

end $xyz$ language plpgsql;

